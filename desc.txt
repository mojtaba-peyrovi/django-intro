django:
part2- making a project
terminal:  django-admin startproject <project_name>
mange.py never edit it. 
url.py   => its like routes/web.php in laravel.  registering routes.
==
to boot the server:  navigate to prject folder:  python manage.py runserver
---------------------
part3:  make an app in the project:   in terminal :  python manage.py startapp <app_name>
---------------------
part4:  
admin.py contains all the admin functionalities
models.py where we can add models, database migrations, schema, etc.
----------------------------------

part 9: 
in order to run the shell( like Tinker in Laravel)  we just have to get into the app folder then say; Python manage.py shell.
when we want to work with database we need to import the models like this:  from music.models import Album, Song (these 2 are the models we made before)
- when we want to see objects we have stored in models we need to say;   Album.objects.all( )
- in order to add objects to the model ==> a = Album(field1="value1", field2="value2", ..........)      and at the end we say   a.save( )
-if you want to see any object of the record we can say;  a.title  and it returns it.
------------------------
part 10:
in order for us to define any specific representation of the model in command line we need to add it to the model as a method like this:

def __str__(sef):
     return self.<field_name1> + <field_name2> + ....  

if we want to see any specific value record based on a criteria we can use <model_name>.filter(<field_name> criteria)
it doesnt accept <> we can use =  
also we can say;   Album.filter(artist__startswith='Taylor') then it returns Taylor Swift and her album
----------------------------
part 11:
we need to make a superuser (admin)     easily we say:   python manage.py createsuperuser
and then we login to the server /admin and login. then we access the backend.
in order to add the models we made in terminal to the backend we just need to say:
          from django.contrib import admin
          from .models import Album
          admin.site.register(Album);
----------------------------
part 12,13 :
whenever we want to make a new view, we first need to add a new url:
   we go to the app we want (here is music) then open urls.py
   inside urls.py inside the urlpatterns array we say:   url(r'^$',<view_name>, name=<route_name>
r: means regular expression     ^ (carrot means the beginning)   $ (means the end)
in order to tell django that it is the id and has to be used in the view later, we say:
url(r'^(?P<album_id>[0-9]+)/$')  ==> [0-9]+  means integer between 0-9 and the the plus means any bigger integer. 
that <album_id> we registered with the url now we can inject it into the view function.
 -----------------------------------
part14:
 templates:
anytime we want to work with templates we need to say:
from django.template import loader
then we need to make a directory called templates under the app directory and inside of it we make a
new folder the same name as the app.
now, inside this inner folder we can make our index,html
then in views we say: template = loader.get_template('music/index.html')   music refers to the inner app 
folder we made inside templates folder.
then we need to define a dictionary and pass all variables we defined and will name is context.
and when we say return HttpResponse(template.render(context, request))
blade templating convention;
  {% for album in all_albums %}
      <li class="list-group-item"><a href="/music/{{ album.id }}">{{ album.album_title }}</a></li>
  {% endfor %}
so similar to laravel.
when we want to know if there is any record in the database using blade;
{% if all_albums %}   then we can add {%else%} and the rest is like laravel.
--------------------------------
part 15:
another way of doing the templating:
form django.shortcuts import render

then we say return render(request, 'music/index.html', context)
--------------------------------------

pat16:
 in order to get 404 error for worng music id numbers we can import it to views.py as:
from django.httml import Http44
then we need to write a try-except error handling and in except part we say: 
raise Http404("<message_we_want_to_display")
---------------------------
part 17:
after making each model we need to define the string representation of the records by writing a method like this:
edf __str__(self):
      return self.<the_field_we_want>  e.g. return self.song_title
IMPORTANT: everytime we add/remove/change any field in a model we need to migrate the models again. 
for adding a song we can do it from terminal by instantiating a Song() object, adding fields one by one and at the end save().
---------------------------
part18:
because we have made a one to many relationship between album and songs we can access songs through the album. 
we can say: album1.song_set.all() ====> this shows all the songs inside album1
anoher way to add a song is:   album1.song_set.create(<pass_all_key_value_pairs_here>)
- if we want to know how many songs are saved in an album:
album1.song_set.count()
--------------------------
part19:
making the details page is similar to Laravel. nothing new.

---------------------------
part20:
we can make this url dynamic: /music/{{ album.id }}
like this:  in the urls page we name each route and now we can use those names to make the routes in html dynamic.
{% url 'detail' album.id %}     -->detail is the name of the route we put at urls.py.   and album.id is the dynamic part of the url.


